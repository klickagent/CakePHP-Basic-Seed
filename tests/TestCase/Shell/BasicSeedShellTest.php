<?php
/**
 * Tests for the BasicSeedShell class.
 */
namespace BasicSeed\Test\TestCase\Shell;

use BasicSeed\Shell\BasicSeedShell;
use Cake\Console\ConsoleIo;
use Cake\Console\ConsoleOptionParser;
use Cake\TestSuite\Stub\ConsoleOutput;
use Cake\TestSuite\TestCase;

use Cake\Cache\Cache;
// use Cake\Console\Shell;
// use Cake\Core\Configure;

/**
 * TestBasicSeedShell class
 *
 * Exposes protected methods for direct testing.
 */
class TestBasicSeedShell extends BasicSeedShell {
// 	public function simpleFetchAndPrint() {
// 		return parent::simpleFetchAndPrint();
// 	}
}

/**
 * BasicSeedShellTest class
 *
 */
class BasicSeedShellTest extends TestCase {

	/**
	 * Fixtures used in this test case
	 *
	 * @var array
	 */
	public $fixtures = [
	];

	/**
	 * Acts as an accumulator for output produced by the Shell.
	 *
	 * @var array
	 * @see ::initSUIT()
	 */
	public $output = [
	];

	public static $datasources = [
		'sample1' => [
			'className' => 'Cake\Database\Connection',
			'driver' => 'Cake\Database\Driver\Mysql',
			'persistent' => false,
			'host' => 'localhost',
			'username' => 'my_app',
			'password' => 'secret',
			'database' => 'my_app',
		],
		'sample2' => [
			'className' => 'Cake\Database\Connection',
			'driver' => 'Cake\Database\Driver\Sqlite',
			'database' => ':memory:',
		],
	];

	public static $salt = 'some salt value';

	/**
	 * Set up some fake datasources and security salt **once** before all tests.
	 *
	 * @return void
	 * @see ::testMainSpecialKeys()
	 */
	public static function setUpBeforeClass() {
		// Prime the ConnectionManager with some configs.
		\Cake\Datasource\ConnectionManager::config(self::$datasources);

		// Prime the security salt.
		\Cake\Utility\Security::salt(self::$salt);
	}

	/**
	 * Purge ConnectionManager configs.
	 *
	 * @return void
	 */
	public static function tearDownAfterClass() {
		foreach (self::$datasources as $ds => $configs) {
			\Cake\Datasource\ConnectionManager::drop($ds);
		}

		\Cake\Utility\Security::salt('');
	}

	/**
	 * setUp method
	 *
	 * @return void
	 */
	public function setUp() {
		parent::setUp();

		$this->output = [];
		$this->Shell = $this->initSUT();
	}

	/**
	 * tearDown method
	 *
	 * @return void
	 */
	public function tearDown() {
		unset($this->io, $this->Shell);
		$this->output = [];

		parent::tearDown();
	}

	/**
	 * Helper for accumulating I/O output generated by the Shell.
	 *
	 * @param string $s The output string being printed.
	 * @see ::initSUT()
	 */
	public function outputCollector($s, $newlines = 1, $level = Shell::NORMAL) {
		$this->output[] = $s;
	}

	/**
	 * Helper for determing the subject class to initialize for testing.
	 *
	 * Methodology:
	 *   - Take the name of this testing class: `SomeObjectTest`
	 *   - If there exists a `TestSomeObject` class (presumed to extend
	 *     SomeObject to expose private/protected methods for testing)
	 *     then return that.
	 *   - Otherwise, guess the namespace of the subject class by
	 *     removing `*\Test\TestCase\*\*Test` from this testing classes
	 *     name and use that.
	 *   - As a side-effect, set a local class property with the
	 *     non-namespaced `SomeObject` name for future reference in tests.
	 *
	 * @return string The fully-namespaced class name to instantiate.
	 * @see ::initSUT()
	 */
	protected function getSUTClassName() {
		$testCaseClass = '\\' . get_class($this);
			// -> ConfigRead\Test\TestCase\Shell\ConfigReadShellTest

		$testingOverrideClass = preg_replace(
			'/^(.*)\\\([^\\\]+)Test$/',
			'\1\\\Test\2',
			$testCaseClass
		); // -> ConfigRead\Test\TestCase\Shell\TestConfigReadShell

		$testedClass = preg_replace(
			'/^(.*)\\\Test\\\TestCase\\\(.*)Test$/',
			'\1\\\\\2',
			$testCaseClass
		); // -> ConfigRead\Shell\ConfigReadShell

		$this->classBasename = preg_replace(
			'/^.*\\\([^\\\]+)$/',
			'\1',
			$testedClass
		); // -> ConfigReadShell

		return (class_exists($testingOverrideClass) ? $testingOverrideClass : $testedClass);
	}

	/**
	 * Helper for setting up an instance of the target Shell with proper
	 * mocked methods.
	 *
	 * The Shell that will be mocked is taken from the test class name
	 * automatically. Example: `SomeShellTest extends CakeTestCase` will
	 * create a mocked copy of `SomeShell`. Will check for a subclassed
	 * `TestSomeShell` and instantiate that instead, if available, to
	 * allow for overriding protected methods.
	 *
	 * All of the fixtures defined in the test class will be "installed"
	 * into the mocked Shell.
	 *
	 * Typically called in ::setUp() or at the beginning
	 * of a test method (if additional mocked methods are necessary.)
	 *
	 * @return mixed A partially mocked copy of the Shell matching the test class's name.
	 */
	protected function initSUT($additionalMocks = []) {
		$defaultMocks = [
			'_displayHelp', 'error',
		];

		$this->io = $this->getMock('\Cake\Console\ConsoleIo', [], [], '', false);
		$this->io->expects($this->any())
			->method('out')
			->with($this->anything())
			->will($this->returnCallback([$this, 'outputCollector']));


		$class = $this->getSUTClassName();
		$mockedMethods = array_merge($defaultMocks, $additionalMocks);
		$shell = $this->getMock(
			$class,
			$mockedMethods,
			[$this->io]
		);

		$shell->expects($this->any())
			->method('error')
			->with($this->anything())
			->will($this->returnCallback([$this, 'outputCollector']));
		$shell->OptionParser = $this->getMock('\Cake\Console\ConsoleOptionParser', [], [null, false]);
		$shell->params = [
			'help' => false,
			'verbose' => false,
			'quiet' => false,
			'file' => null,
			'dev' => false,
		];

		return $shell;
	}

	/**
	 * test that main finds core shells.
	 *
	 * @return void
	 */
	public function testGetOptionParser() {
		$result = $this->Shell->getOptionParser();
		$this->assertInstanceOf(
			'Cake\Console\ConsoleOptionParser',
			$result,
			'Cursory sanity check. getOptionParser() should return an option parse instance.'
		);
	}

	/**
	 * Confirm that startup() engages help output when flag is present.
	 *
	 * @return void
	 */
	public function testStartupHelp() {
		$this->Shell->expects($this->once())
			->method('_displayHelp');

		Cache::config('_cake_core_', [
			'className' => 'File',
		]);
		$this->Shell->startup();

		$this->assertContains(
			'Provides a mechanism for loading data into any of Cake\'s configured',
			$this->output,
			'Shell should output help() when no args are provided.'
		);
	}

	/**
	 * test main().
	 *
	 * @return void
	 */
	public function testMainSimple() {
		$this->markTestIncomplete('@TODO: write test for main().');

		$expected = [
			'key' => 'val',
			'debug' => true,
			'ary' => [
				'foo' => 'bar',
				'fizz' => 'buzz',
			],
		];

		$shell = $this->initSUT(['fetchVal', 'iterateOnKey']);
		$shell->args = array_keys($expected);

		$i = 0;
		foreach ($expected as $k => $v) {
			$shell->expects($this->at($i++))
				->method('fetchVal')
				->with($k)
				->will($this->returnValue($v));
			$shell->expects($this->at($i++))
				->method('iterateOnKey')
				->with($k, $v);
		}

		// Can't use runCommand() because it requires a host Cake app.
		//$shell->runCommand(array_keys($expected));
		// So simulate startup and execution directly:
		$shell->startup();
		$shell->main();

		$this->assertTrue(
			$shell->formatBash,
			'Bash output should be engaged automatically by presence of multiple command line args.'
		);
	}

	/**
	 * test main(), including associated protected methods, using simple output.
	 *
	 * @return void
	 */
	public function testMainSimpleIntegration() {
		$this->markTestIncomplete('@TODO: write test for main().');

		$configure = [
			'key' => 'val',
			'debug' => true,
			'ary' => [
				'foo' => 'bar',
				'fizz' => 'buzz',
			],
		];
		$expected = [
			"KEY='val'",
			"DEBUG='1'",
			"ARY_FOO='bar'",
			"ARY_FIZZ='buzz'",
		];
		Configure::write($configure);
		$this->Shell->args = array_keys($configure);

		$this->Shell->startup();
		$this->Shell->main();

		$this->assertEquals(
			$expected,
			$this->output,
			'The output produced from running the shell on the given arguments should match our expected result.'
		);
		$this->assertTrue(
			$this->Shell->formatBash,
			'Bash output should be engaged automatically by presence of multiple command line args.'
		);
	}

	/**
	 * test main(), including associated protected methods, using simple output.
	 *
	 * @param array $args Array of arguments to seed the Shell->args with.
	 * @param array $expected Array of generated output lines to compare to ::$output.
	 * @param string $msg Optional PHPUnit assertion failure message.
	 * @return void
	 * @dataProvider provideSerializedArgs
	 */
	public function testMainSerializedIntegration($args, $expected, $msg = '') {
		$this->markTestIncomplete('@TODO: write test for main().');

		$configure = [
			'key' => 'val',
			'debug' => true,
			'ary' => [
				'one' => 1,
				'two' => '2',
				3 => 'three',
				'stdClass' => (new \StdClass()),
			],
		];

		Configure::write($configure);
		$this->Shell->params['serialize'] = true;
		$this->Shell->args = $args;

		$this->Shell->startup();
		$this->Shell->main();

		$this->assertEquals(
			$expected,
			$this->output,
			$msg
		);
		$this->assertTrue(
			$this->Shell->formatSerialize,
			'Serialized output should be engaged from the provided param.'
		);
	}

	/**
	 * Provides input arguments to testMainSerializedIntegration().
	 *
	 * All keys named in the [args] elements must exist in
	 * $configure as defined in testMainSerializedIntegration() above.
	 *
	 * @return array
	 */
	public function provideSerializedArgs() {
		return [
			[
				[''], // Args to load in the Shell.
				['N;'], // Expected lines of output.
				'Empty input should produce a serialized `null` string.', // PHPUnit assertion failure message.
			],

			[
				['key'],
				['s:3:"val";'],
				'Single scalar value should be serialized directly.',
			],

			[
				['key', 'ary.stdClass'],
				['a:2:{s:3:"key";s:3:"val";s:12:"ary.stdClass";O:8:"stdClass":0:{}}'],
				'Multiple requested keys should be combined into a (serialized) associative array.',
			],
		];
	}
}
