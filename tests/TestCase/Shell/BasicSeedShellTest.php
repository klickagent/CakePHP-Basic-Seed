<?php
/**
 * Tests for the BasicSeedShell class.
 */

namespace BasicSeed\Test\TestCase\Shell;

use BasicSeed\Shell\BasicSeedShell;
use Cake\Cache\Cache;
use Cake\Console\ConsoleIo;
use Cake\Console\ConsoleOptionParser;
use Cake\TestSuite\Stub\ConsoleOutput;
use Cake\TestSuite\TestCase;

/**
 * TestBasicSeedShell class
 *
 * Exposes protected methods for direct testing.
 */
class TestBasicSeedShell extends BasicSeedShell {
// 	public function simpleFetchAndPrint() {
// 		return parent::simpleFetchAndPrint();
// 	}
/*
	truncateTable
	findKey
	printValidationErrors
	getFile
	existsOrCreate
	absolutePath
*/
}

/**
 * BasicSeedShellTest class
 */
class BasicSeedShellTest extends TestCase {

	/**
	 * Fixtures used in this test case
	 *
	 * @var array
	 */
	public $fixtures = [
	];

	/**
	 * Acts as an accumulator for output produced by the Shell.
	 *
	 * @var array
	 * @see ::initSUIT()
	 */
	public $output = [
	];

	public static $datasources = [
		'sample1' => [
			'className' => 'Cake\Database\Connection',
			'driver' => 'Cake\Database\Driver\Mysql',
			'persistent' => false,
			'host' => 'localhost',
			'username' => 'my_app',
			'password' => 'secret',
			'database' => 'my_app',
		],
		'sample2' => [
			'className' => 'Cake\Database\Connection',
			'driver' => 'Cake\Database\Driver\Sqlite',
			'database' => ':memory:',
		],
	];

	public static $salt = 'some salt value';

	/**
	 * Set up some fake datasources and security salt **once** before all tests.
	 *
	 * @return void
	 * @see ::testMainSpecialKeys()
	 */
	public static function setUpBeforeClass() {
		// Prime the ConnectionManager with some configs.
		\Cake\Datasource\ConnectionManager::config(self::$datasources);

		// Prime the security salt.
		\Cake\Utility\Security::salt(self::$salt);
	}

	/**
	 * Purge ConnectionManager configs.
	 *
	 * @return void
	 */
	public static function tearDownAfterClass() {
		foreach (self::$datasources as $ds => $configs) {
			\Cake\Datasource\ConnectionManager::drop($ds);
		}

		\Cake\Utility\Security::salt('');
	}

	/**
	 * setUp method
	 *
	 * @return void
	 */
	public function setUp() {
		parent::setUp();

		$this->output = [];
		$this->Shell = $this->initSUT();
	}

	/**
	 * tearDown method
	 *
	 * @return void
	 */
	public function tearDown() {
		unset($this->io, $this->Shell);
		$this->output = [];

		parent::tearDown();
	}

	/**
	 * Helper for accumulating I/O output generated by the Shell.
	 *
	 * @param string $s The output string being printed.
	 * @see ::initSUT()
	 */
	public function outputCollector($s, $newlines = 1, $level = Shell::NORMAL) {
		$this->output[] = $s;
	}

	/**
	 * Helper for determing the subject class to initialize for testing.
	 *
	 * Methodology:
	 *   - Take the name of this testing class: `SomeObjectTest`
	 *   - If there exists a `TestSomeObject` class (presumed to extend
	 *     SomeObject to expose private/protected methods for testing)
	 *     then return that.
	 *   - Otherwise, guess the namespace of the subject class by
	 *     removing `*\Test\TestCase\*\*Test` from this testing classes
	 *     name and use that.
	 *   - As a side-effect, set a local class property with the
	 *     non-namespaced `SomeObject` name for future reference in tests.
	 *
	 * @return string The fully-namespaced class name to instantiate.
	 * @see ::initSUT()
	 */
	protected function getSUTClassName() {
		$testCaseClass = '\\' . get_class($this);
			// -> ConfigRead\Test\TestCase\Shell\ConfigReadShellTest

		$testingOverrideClass = preg_replace(
			'/^(.*)\\\([^\\\]+)Test$/',
			'\1\\\Test\2',
			$testCaseClass
		); // -> ConfigRead\Test\TestCase\Shell\TestConfigReadShell

		$testedClass = preg_replace(
			'/^(.*)\\\Test\\\TestCase\\\(.*)Test$/',
			'\1\\\\\2',
			$testCaseClass
		); // -> ConfigRead\Shell\ConfigReadShell

		$this->classBasename = preg_replace(
			'/^.*\\\([^\\\]+)$/',
			'\1',
			$testedClass
		); // -> ConfigReadShell

		return (class_exists($testingOverrideClass) ? $testingOverrideClass : $testedClass);
	}

	/**
	 * Helper for setting up an instance of the target Shell with proper
	 * mocked methods.
	 *
	 * The Shell that will be mocked is taken from the test class name
	 * automatically. Example: `SomeShellTest extends CakeTestCase` will
	 * create a mocked copy of `SomeShell`. Will check for a subclassed
	 * `TestSomeShell` and instantiate that instead, if available, to
	 * allow for overriding protected methods.
	 *
	 * All of the fixtures defined in the test class will be "installed"
	 * into the mocked Shell.
	 *
	 * Typically called in ::setUp() or at the beginning
	 * of a test method (if additional mocked methods are necessary.)
	 *
	 * @return mixed A partially mocked copy of the Shell matching the test class's name.
	 */
	protected function initSUT($additionalMocks = []) {
		$defaultMocks = [
			'_displayHelp', 'error',
		];

		$this->io = $this->getMock('\Cake\Console\ConsoleIo', [], [], '', false);
		$this->io->expects($this->any())
			->method('out')
			->with($this->anything())
			->will($this->returnCallback([$this, 'outputCollector']));


		$class = $this->getSUTClassName();
		$mockedMethods = array_merge($defaultMocks, $additionalMocks);
		$shell = $this->getMock(
			$class,
			$mockedMethods,
			[$this->io]
		);

		$shell->expects($this->any())
			->method('error')
			->with($this->anything())
			->will($this->returnCallback([$this, 'outputCollector']));
		$shell->OptionParser = $this->getMock('\Cake\Console\ConsoleOptionParser', [], [null, false]);
		$shell->params = [
			'help' => false,
			'verbose' => false,
			'quiet' => false,
			'file' => null,
			'dev' => false,
		];

		return $shell;
	}

	/**
	 * test that main finds core shells.
	 *
	 * @return void
	 */
	public function testGetOptionParser() {
		$result = $this->Shell->getOptionParser();
		$this->assertInstanceOf(
			'Cake\Console\ConsoleOptionParser',
			$result,
			'Cursory sanity check. getOptionParser() should return an option parse instance.'
		);
	}

	/**
	 * test init().
	 *
	 * @return void
	 */
	public function testInit() {
		$this->markTestIncomplete('@TODO: write test for init().');
	}

	/**
	 * test main().
	 *
	 * @return void
	 */
	public function testMain() {
		$this->markTestIncomplete('@TODO: write test for main().');
	}

	/**
	 * test importTables().
	 *
	 * @return void
	 */
	public function testImportTables() {
		$this->markTestIncomplete('@TODO: write test for importTables().');
	}

	/**
	 * test entityGenerator().
	 *
	 * @return void
	 */
	public function testEntityGenerator() {
		$this->markTestIncomplete('@TODO: write test for entityGenerator().');
	}

	/**
	 * test importTable().
	 *
	 * @return void
	 */
	public function testImportTable() {
		$this->markTestIncomplete('@TODO: write test for importTable().');
	}

	/**
	 * test truncateTable().
	 *
	 * @return void
	 */
	public function testTruncateTable() {
		$this->markTestIncomplete('@TODO: write test for truncateTable().');
	}

	/**
	 * test findKey().
	 *
	 * @return void
	 */
	public function testFindKey() {
		$this->markTestIncomplete('@TODO: write test for findKey().');
	}

	/**
	 * test printValidationErrors().
	 *
	 * @return void
	 */
	public function testPrintValidationErrors() {
		$this->markTestIncomplete('@TODO: write test for printValidationErrors().');
	}

	/**
	 * test getFile().
	 *
	 * @return void
	 */
	public function testGetFile() {
		$this->markTestIncomplete('@TODO: write test for getFile().');
	}

	/**
	 * test existsOrCreate().
	 *
	 * @return void
	 */
	public function testExistsOrCreate() {
		$this->markTestIncomplete('@TODO: write test for existsOrCreate().');
	}

	/**
	 * test absolutePath().
	 *
	 * @return void
	 */
	public function testAbsolutePath() {
		$this->markTestIncomplete('@TODO: write test for absolutePath().');
	}

}
